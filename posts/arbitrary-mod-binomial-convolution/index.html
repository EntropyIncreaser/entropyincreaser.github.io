<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.74.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="http://entropyincreaser.github.io/posts/arbitrary-mod-binomial-convolution/" />
  <link rel="canonical" href="http://entropyincreaser.github.io/posts/arbitrary-mod-binomial-convolution/" /><link rel="preload" href="/js/highlight.pack.js" as="script" /><link rel="alternate" type="application/atom+xml" href="http://entropyincreaser.github.io/index.xml" title="Elegia&#39;s Thoughts">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "http:\/\/entropyincreaser.github.io\/"
      },
      "articleSection" : "posts",
      "name" : "任意模数二项卷积",
      "headline" : "任意模数二项卷积",
      "description" : "二项卷积：\n$$ c_n = \\sum_k \\binom n k a_k b_{n-k} $$\n当模数 $M$ 有一质因子 $p\\le n$ 时，计算二项卷积无法直接变为 EGF 进行计算，因为 $n!$ 此时不可逆。\n 我们考虑首先如何解决 $M = p^k$ 时的情况，然后可以用 CRT 合并各情况。\n我们记 $v_p(n)$ 是 $n!$ 中 $p$ 的质因子次数，$p$-阶乘为 $n!_p = p^{v_p(n)}$，反 $p$-阶乘为 $\\overline{n!_p} = \\frac{n!}{n!_p}$。\n那么由定义显然 $\\overline{n!_p}$ 还是同余 $M$ 可逆的。我们先令 $\\widehat a_n = a_n \\cdot \\left( \\overline{n!_p} \\right)^{-1} \\bmod M$，我们可以得到\n$$ \\widehat c_n \\equiv \\sum_k \\left(\\frac{n!_p}{k!_p (n-k)!_p}\\right) \\widehat a_k \\widehat b_{n-k} \\equiv \\sum_k p^{v_p(n)-v_p(k)-v_p(n-k)} \\widehat a_k \\widehat b_{n-k} \\pmod M $$",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2020",
      "datePublished": "2020-08-23 20:39:36 \u002b0800 CST",
      "dateModified" : "2020-08-23 20:39:36 \u002b0800 CST",
      "url" : "http:\/\/entropyincreaser.github.io\/posts\/arbitrary-mod-binomial-convolution\/",
      "keywords" : [  ]
  }
</script>
<title>任意模数二项卷积 - Elegia&#39;s Thoughts</title>
  <meta property="og:title" content="任意模数二项卷积 - Elegia&#39;s Thoughts" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="二项卷积：
$$ c_n = \sum_k \binom n k a_k b_{n-k} $$
当模数 $M$ 有一质因子 $p\le n$ 时，计算二项卷积无法直接变为 EGF 进行计算，因为 $n!$ 此时不可逆。
 我们考虑首先如何解决 $M = p^k$ 时的情况，然后可以用 CRT 合并各情况。
我们记 $v_p(n)$ 是 $n!$ 中 $p$ 的质因子次数，$p$-阶乘为 $n!_p = p^{v_p(n)}$，反 $p$-阶乘为 $\overline{n!_p} = \frac{n!}{n!_p}$。
那么由定义显然 $\overline{n!_p}$ 还是同余 $M$ 可逆的。我们先令 $\widehat a_n = a_n \cdot \left( \overline{n!_p} \right)^{-1} \bmod M$，我们可以得到
$$ \widehat c_n \equiv \sum_k \left(\frac{n!_p}{k!_p (n-k)!_p}\right) \widehat a_k \widehat b_{n-k} \equiv \sum_k p^{v_p(n)-v_p(k)-v_p(n-k)} \widehat a_k \widehat b_{n-k} \pmod M $$" />
  <meta name="description" content="二项卷积：
$$ c_n = \sum_k \binom n k a_k b_{n-k} $$
当模数 $M$ 有一质因子 $p\le n$ 时，计算二项卷积无法直接变为 EGF 进行计算，因为 $n!$ 此时不可逆。
 我们考虑首先如何解决 $M = p^k$ 时的情况，然后可以用 CRT 合并各情况。
我们记 $v_p(n)$ 是 $n!$ 中 $p$ 的质因子次数，$p$-阶乘为 $n!_p = p^{v_p(n)}$，反 $p$-阶乘为 $\overline{n!_p} = \frac{n!}{n!_p}$。
那么由定义显然 $\overline{n!_p}$ 还是同余 $M$ 可逆的。我们先令 $\widehat a_n = a_n \cdot \left( \overline{n!_p} \right)^{-1} \bmod M$，我们可以得到
$$ \widehat c_n \equiv \sum_k \left(\frac{n!_p}{k!_p (n-k)!_p}\right) \widehat a_k \widehat b_{n-k} \equiv \sum_k p^{v_p(n)-v_p(k)-v_p(n-k)} \widehat a_k \widehat b_{n-k} \pmod M $$" />
  <meta property="og:locale" content="zh-cn" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet" href="/css/github-markdown.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Elegia&#39;s Thoughts">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel="stylesheet">
  
  

  
</head>

<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          <script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

        </div>
        <header class="post-header">
          <h1 class="post-title">任意模数二项卷积</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2020-08-23 20:39:36 CST">
                23 Aug 2020
              </time>
              
            </div>
            <div class="col-xs-6">
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>二项卷积：</p>
<p>$$
c_n = \sum_k \binom n k a_k b_{n-k}
$$</p>
<p>当模数 $M$ 有一质因子 $p\le n$ 时，计算二项卷积无法直接变为 EGF 进行计算，因为 $n!$ 此时不可逆。</p>
<hr>
<p>我们考虑首先如何解决 $M = p^k$ 时的情况，然后可以用 CRT 合并各情况。</p>
<p>我们记 $v_p(n)$ 是 $n!$ 中 $p$ 的质因子次数，$p$-阶乘为 $n!_p = p^{v_p(n)}$，反 $p$-阶乘为 $\overline{n!_p} = \frac{n!}{n!_p}$。</p>
<p>那么由定义显然 $\overline{n!_p}$ 还是同余 $M$ 可逆的。我们先令 $\widehat a_n = a_n \cdot \left( \overline{n!_p} \right)^{-1} \bmod M$，我们可以得到</p>
<p>$$
\widehat c_n \equiv \sum_k \left(\frac{n!_p}{k!_p (n-k)!_p}\right) \widehat a_k \widehat b_{n-k} \equiv \sum_k p^{v_p(n)-v_p(k)-v_p(n-k)} \widehat a_k \widehat b_{n-k} \pmod M
$$</p>
<p>而 $d = v_p(n)-v_p(k)-v_p(n-k)$ 可以推出就是在 $p$ 进制下，$n$ 减去 $k$ 时所发生的退位次数。（这个被叫做 Kummer 定理，过程略）</p>
<p>而 $n$ 在 $p$ 进制下最多只有 $\log_p n$ 位可退，因此我们知道 $p^d \le n$，因此我们在<strong>不取模</strong>的情况下，可以得到 $\widehat c_n \le n \cdot nM^2 = n^2M^2$。</p>
<p>虽然 $p$ 在模 $M$ 下不可逆，但是当 $p\le n$，自然满足在我们选取的 NTT 模数下都可逆！因此，这一涉及除法的卷积式子，因为已经保证了结果是值域在 $n^2M^2$ 内的整数，所以我们只需选取 NTT 模数进行卷积，之后用 CRT 合并即可。取 $n\le 10^6, M\le 10^9$ 的一般情况下，可得 $c_n \le 10^{30}$，使用四个 NTT 模数进行合并足够。</p>
<p>因此对于每个 $M=p^k$ 的情况，我们都可以通过“四模数 NTT”进行计算，那么对于一般的 $M$ 进行 CRT，算法的复杂度为 $\Theta(n\log n \cdot \omega(M))$，或者也可以解释为，结果值域是 $n^{1+\omega(M)}M^2$ 的卷积。</p>
<hr>
<p><a href="https://loj.ac/submission/867120">该提交记录</a> 是一个不算精细的实现。在 $\omega(M)$ 取到最大时大概效率是 loj 的 1s 上下波动（其实这个时候每次 CRT 不用四模数了，如果考虑这一点还能更快）。暂时没想到在“四模数 NTT”的时候避免 int128 的方法。</p>
<hr>
<p>特殊情况：</p>
<ul>
<li>$p$ 很小的时候可以类比子集卷积，加一个占位多项式来帮助计算，但是这个做法的复杂度看起来会带 $p$ 和 $\log_p n$，在 $p$ 大的时候尚未想到能从此想法得到什么优秀的做法。之前思考这个问题的时候也在这里困惑了很久。</li>
</ul>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
          </div>
        </div>
        
          <div class="row">
            <div class="col-xs-12">
              
            </div>
          </div>

          


          
          
          <div style="height: 50px;"></div>
          
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  
  
    
    
  
</script>

  

</body>

</html>